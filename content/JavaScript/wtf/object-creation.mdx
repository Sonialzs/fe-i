---
slug: 'object-creation'
date: '2020-11-25'
category: 'JavaScript'
index: 8
authors:
    - cuvii
authorsUrl:
    - https://fei.kodin.fun
draft: false
---

## 工厂模式

工厂模式就是一个函数，在函数内部完成对象的创建并返回。

比如一个阅读软件中，需要创建书籍信息，那么根据工厂模式，可以这样实现：

```js run
function createBook(name, id) {
	const book = { name, id };
	book.onRead = function (username) {
		console.log(`${username} 正在阅读书籍：${name}`);
	};

	return book;
}

const sanguoyanyi = createBook('三国演义', '123');
sanguoyanyi.onRead('cuvii');
```

使用工厂模式可以很方便地创建多个对象，但是存在一个问题：无法确定对象的类型。

```js
console.log(sanguoyanyi instanceof createBook); // false
console.log(sanguoyanyi.constructor === createBook); //false
```

## 构造函数模式

构造函数可以通过 new 关键字调用，函数内部 this 会自动指向新对象，并且不需要手动返回新对象。

```js run
function Book(name, id) {
	this.name = name;
	this.id = id;
	this.onRead = function (username) {
		console.log(`${username}正在阅读书籍：${name}`);
	};
}

const hongloumeng = new Book('红楼梦', '123');
hongloumeng.onRead('cuvii');

console.log(hongloumeng instanceof Book);
console.log(hongloumeng.constructor === Book);
```

对于构造函数，按照惯例首字母需要大写。 通过 new 关键字调用函数时，会执行以下几步：

1. 创建一个新对象。
2. 将 this 指向新对象。
3. 执行函数中的代码。
4. 如果函数中没有默认返回值，就返回新对象。

通过构造函数创建的对象，可以确定对象的类型。

```js
console.log(hongloumeng instanceof Book); // true
console.log(hongloumeng.constructor === Book); // true
```

构造函数的问题在于，不能共享方法。比如这个例子中的 onRead()方法，会存在于每个对象上，而不是对象的原型上。当创建多个对象时，会造成额外的内存开销。

可以把函数移动到构造函数之外来避免这个问题。

```js
function Book(name, id) {
	this.name = name;
	this.id = id;
	this.onRead = onReadHandler;
}

function onReadHandler(username) {
	console.log(`${username}正在阅读书籍：${this.name}`);
}
```

## 原型模式

原型模式通过借助 JavaScript 中的原型机制来实现。

在 JavaScript 中，每个函数都有一个`prototype`属性，它是一个对象，默认有一个`constructor`属性，指向函数本身。

比如在构造函数的例子中，定义了一个`Book`函数，可以通过`Book.prototype`访问`Book`函数的原型对象。推荐在 Chrome 浏览器的开发工具中尝试一下。

![函数-原型对象-构造函数的关系](/static/js/wtf/objects/function-prototype-constructor.png)

每一次调用构造函数创建的实例对象，比如`hongloumeng`，其内部都有一个`[[Prototype]]`指针指向`Book.prototype`。在 Chrome、Firefox、Safari 等浏览器中，可以通过实例对象的`__proto__`属性来访问原型对象。

![实例对象-__proto__-原型对象的关系](/static/js/wtf/objects/instance-proto-prototype.png)

通过调用 `Book` 构造函数创建了 `hongloumeng` 对象，红楼梦对象有`__proto__`属性，而且`__proto__`指向`Book.prototype`(图中红色箭头的关系)。

这就是[原型链](/js/wtf/prototype-chain)。

根据原型链的规则，访问对象上的变量或者方法时，会在自身查找，如果找不到，就通过`__proto__`去原型对象上查找。

举个简单的栗子，通过对象字面量创建两个对象，people 和 animal。通过 `hasOwnProperty()` 检测 `people` 对象上是否有`age`这个属性。

```js
const people = { name: 'people' };
const animal = { name: 'animal' };

console.log(people.hasOwnProperty('age')); // false。
```

问题来了，`hasOwnProperty()`这个方法哪里来的？`hasOwnProperty` 是 `Object` 的方法，用于检测一个对象是不是自身就有这个属性（也就是不考虑原型链）。

实际上`peopel.hasOwnProperty()`的调用逻辑是这样的：

1. 到 people 对象上找 hasOwnProperty 这个属性。如果找到了就尝试调用；如果没有找到，就进入下一步；
2. 检查 people 对象上的`__proto__（[[Prototype]]）`属性，如果没有就停止查找，报错；
3. 在`people.__proto__`上查找`hasOwnProperty`属性，找到就尝试调用。如果没有找到，就进入下一步；
4. 检查`people.__proto__.__proto__`属性，如果没有有就继续查找`hasOwnProperty`属性；
5. 如此反复，直到原型链顶部为止。

实际上在第 3 步就已经找到`hasOwnProperty`这个属性了。因为 `people` 的原型就是 `Object`。

```js
console.log(people.__proto__ === Object.prototype); // true
console.log(
	people.__proto__.hasOwnProperty === Object.prototype.hasOwnProperty
); // true
```

这就是原型链。此外，因为`people`和`animal`的原型都是 `Object`，所以二者都可以访问 `hasOwnProperty`。

通过这个栗子可以清楚知道，可以将方法保存在构造函数的原型对象上，那么基于这个构造函数创建的对象，都可以访问原型对象上的方法。那么接下来对构造函数例子中的代码稍作修改。

```js run
function Book(name, id) {
	this.name = name;
	this.id = id;
}

Book.prototype.onRead = function (username) {
	console.log(`${username}正在阅读书籍：${this.name}`);
};

const book1 = new Book('book1', '1');
book1.onRead('cuvii');

const book2 = new Book('book2', '2');
book2.onRead('cuvii');
```

现在是在 `Book.prototype` 上添加方法，这样所有 `Book` 的实例对象都可以访问到`onRead()`方法了。

另外，由于原型对象中的属性是共享的，如果修改原型对象上的属性，那么也会影响到后续调用，比如：

```js run
function Person() {}

Person.prototype.country = 'CN';

const hubeiren1 = new Person();
console.log(hubieiren1.country);

Person.prototype.country = 'MARS';
console.log(hubieiren1.country);
```

在构造函数中通过 `this` 添加的属性是在实例上的，和原型没有任何关系，所以不会产生互相影响的问题。

## 迭代模式

TODO

## 参考文档

> -   [《JavaScript 高级程序设计 第四版》 —— 创建对象](https://m.ituring.com.cn/book/2472)
