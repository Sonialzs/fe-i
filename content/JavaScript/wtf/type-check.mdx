---
title: '类型判断'
slug: 'type-check'
date: '2020-11-23'
category: 'JavaScript'
index: 2
authors:
    - cuvii
authorsUrl:
    - https://fei.kodin.fun
draft: false
---

### 总结

`typeof` 可以判断**值类型**和 **object**以及**function**。但是存在` typeof null` 返回`object`的 bug。

`instanceof` 是根据原型链来判断，只能判断对象。

`constructor` 是根据构造函数进行判断。

`Object.prototype.toString.call()`可以判断任何类型。

## typeof

```js:typeof run
console.log(typeof 123);
console.log(typeof 'cuvii');
console.log(typeof true);
console.log(typeof null); // "object"
console.log(typeof undefined);
console.log(typeof {}); // "object"
console.log(typeof []); // "object"
function fn() {}
console.log(typeof fn);
```

`typeof []`并没有返回`"array"`，而是`object`。因为在 JavaScript 中，数组 Array、函数 Function 等都是派生自`object`的（还有 Date、Error、Map 等，详见[引用类型]()），而 typeof 对于引用类型只能判断 object 和 function，对于数组、Date、Map 等都返回`object`。

这是 `typeof` 的局限性，无法准确判断引用类型。

第四行代码中，`typeof null`也返回了`object`。`null` 是值类型，为什么被判断成了`object`？

这是 JavaScript 的 bug。

在 JavaScript 第一个版本中，变量以**类型标签**(typetag)和**值**来表示。`object`的类型标签是 0，而` null` 是用来表示空指针的，大多数平台下值为`0x00`，也被当作 0 处理。

## instanceof

`instanceof` 用来判断引用类型的类型，准确来说是，判断右侧类的构造函数是否出现在左侧对象的原型链上。例如：

```js:instanceof run
const o = {};

console.log(o instanceof Object)
```

```js:instanceof1 run
console.log(123 instanceof Number);
console.log(`cuvii` instanceof String);
console.log(true instanceof Boolean);
console.log(null instanceof Object);
```

从这段代码中可以看到，对于值类型的判断都返回 `false`。也就是说，`instanceof `不能判断值类型，只能判断引用类型的类型。

```js:instanceof2 run

function fn(){}
console.log(fn instanceof Function)
console.log(fn instanceof Object)
```

因为 `Function` 类继承自 `Object`，所以结果都为 `true`。

## constructor

`constructor`是直接使用构造函数来进行判断，不考虑原型链。

```js:constructor run
const number = 1;
const boolean = true;
const string = 'cuvii'
const func = function(){}
const object = {}
class Person{}
const p1 = new Person()

console.log(number.constructor === Number) // true
console.log(boolean.constructor === Boolean) //true
console.log(string.constructor === String) //true
console.log(func.constructor === Function) //true
console.log(object.constructor === Object) // true
console.log(p1.constructor === Person) // true
// ❗并不考虑原型链
console.log(func.constructor === Object) //false

```

通过 constructor 能准确判断值类型和引用类型具体是什么类型。但是有一个隐患在于，constructor 是可以修改的！以上代码中，对 p1 稍作修改：

```js run
class Person {}
const p1 = new Person();
p1.constructor = Object;
console.log(p1.constructor === Person); // false
```

## Object.prototype.toString.call()

`Object.prototype.toString.call()`是更完善一点的类型判断方法，可以判断任何类型。
`Object.prototype.toString` 方法会输出`[object [[Class]]]`这样的值，其中`[[Class]]`就是对象的 `class` 属性。

> 每个 JavaScript 对象都有一个内部属性`[[Class]]`。

通过这个方法，可以准确获取到对象的类型。

```js:Object.prototype.toString.call()
var num = 123;
var str = 'abcdef';
var bool = true;
var arr = [1, 2, 3, 4];
var json = { name: 'jsliang', age: 25 };
var func = function () { console.log('this is function'); }
var und = undefined;
var nul = null;
var date = new Date();
var reg = /^[a-zA-Z]{5,20}$/;
var error = new Error();

console.log(
    Object.prototype.toString.call(num), // [object Number]
    Object.prototype.toString.call(str), // [object String]
    Object.prototype.toString.call(bool), // [object Boolean]
    Object.prototype.toString.call(arr), // [object Array]
    Object.prototype.toString.call(json), // [object Object]
    Object.prototype.toString.call(func), // [object Function]
    Object.prototype.toString.call(und), // [object Undefined]
    Object.prototype.toString.call(nul), // [object Null]
    Object.prototype.toString.call(date), // [object Date]
    Object.prototype.toString.call(reg), // [object RegExp]
    Object.prototype.toString.call(error), // [object Error]
  );

```

以上代码片段取自[jsliang 求职系列 - 04 - JavaScript 变量](https://juejin.cn/post/6891457912171200525#heading-14)。

### 参考

-   [The history of “typeof null”](https://2ality.com/2013/10/typeof-null.html)
-   🔥[Fixing the JavaScript typeof operator](https://javascriptweblog.wordpress.com/2011/08/08/fixing-the-javascript-typeof-operator/)
-   [Class checking: "instanceof"](https://javascript.info/instanceof)
