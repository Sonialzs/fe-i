---
title: '对象 API'
slug: 'object-api'
date: '2020-11-25'
category: 'JavaScript'
index: 9
authors:
    - cuvii
authorsUrl:
    - https://fei.kodin.fun
draft: false
---

## 构造函数

`Object()`当作构造函数使用时，有以下几种情况：

1.  如果参数是 `null` 或者 `undefined` 或者不传入参数，会返回一个空对象。

```js
Object(null); // {}
Object(undefined); // {}
Object(); // {}
```

2.  否则返回一个参数相同类型的对象。或者说包装后的对象。

```js
Object(1); // Number(1)
Object(NaN); // Number(NaN) NaN也是数字嗷
Object('str'); // String('str')
Object(true); // Boolean(true)
```

1.  如果参数就是一个对象，那直接返回参数。

```js run
const arr = [1, 2, 3];
const fn = function () {};
const obj = {};

console.log(Object(arr) === arr);
console.log(Object(fn) === fn);
console.log(Object(obj) === obj);
```

## 静态方法

### 🔥`Object.assign()`

`Object.assign()`方法将两个对象的**可遍历**、**自身属性**合并。

通过 `Object.prototype.propertyIsEnumerable()`来检测属性是不是可遍历的。

通过 `Object.prototype.hasOwnProperty()`来检测是不是自身属性。

```js run
const o1 = {
	name: 'cuvii',
	age: 23,
};

const o2 = {
	count: 2,
	sum: 3,
};

Object.defineProperty(o2, 'total', {
	enumerable: false,
	value: 666,
});

console.log(Object.assign(o1, o2));
```

👆 上面这段代码中，设置 enumerable 的属性 total 就没有合并到新的对象中去。

### 🔥`Object.create()`

`Object.create()`方法会创建一个**新的对象**，新对象会将参数作为原型。

```js run
const cuvii = { name: 'cuvii', age: 23 };

const lilith = Object.create(cuvii);

console.log(lilith);
console.log(lilith.__proto__ === cuvii);
```

👆 代码中可以看到，`lilith` 是一个空对象，且`__proto__`直接指向了 `cuvii`。

如果不传入参数或者传入 undefined，是会报错的嗷！不过可以将 null 作为参数，新对象会没有`__proto__`属性，也就是没有原型。

```js run
const obj = Object.create(null);

console.log(obj.__proto__ === undefined); // true
```

### 🔥`Object.defineProperty()`

`Object.defineProperty`方法可以在对象上定义一个新属性，或者修改已有的属性。和直接在对象上添加属性不同，这个方法可以对属性进行配置。

```js run
const o = {
	name: 'cuvii',
};

// 将o.name变为不可写
Object.defineProperty(o, 'name', {
	writable: false,
});

// 这行代码不会修改name的值，也不会报错。
o.name = 'lilith';

console.log(o.name); // "cuvii"

// 添加一个o.age属性，值为23
Object.defineProperty(o, 'age', {
	writable: false,
	value: 23,
});

console.log(o.age); // 23
```

除了 4 个可配置特性`configurable`,`enumerable`,`wrtiable`,`value`之外，还可以配置 `getter` 和 `setter`。
Vue 2 中的响应式就是通过 `getter` 和 `setter` 实现的。顺带一提，Vue3 是使用`Proxy`。

```js run
const bank = {
	_money: 80,
};

Object.defineProperty(bank, 'account', {
	get() {
		return `余额是${bank._money}`;
	},
	set(value) {
		const result = this.money + value;
		bank._money = result >= 0 ? result : 0;
	},
});

console.log(bank.account);
bank.account = -1;
console.log(bank.account);
```

👆 代码中，为 `bank` 对象定义了一个 `account` 属性，并设置了 `getter`，调用时会返回一段字符串，在 `setter` 中限制 `money` 最小为 0。

### `Object.defineProperties()`

`Object.defineProperties()`方法支持定义多个属性。

```js
const o = {};

Object.defineProperties(o, {
	name: {
		value: 'lilith',
		writable: false,
	},

	age: {
		value: 18,
		writable: false,
	},
});
```

### 🔥`Object.entires()`

`Object.entires()`会以数组形式返回对象自身的所有可遍历键值对，不保证顺序。

> for...in 循环也可以遍历对象的键，但会包括原型链上的所有键。

```js
const book = {
	name: '三国演义',
	author: '罗贯中',
	summary: '历史小说',
	rate: 5.0,
};

console.log(Object.entries(book));
```

输出结果为：

```js
[
	['name', '三国演义'],
	['author', '罗贯中'],
	['summary', '历史小说'],
	['rate', 5],
];
```

### `Object.freeze()`

```js run
const obj = {
	price: 15,
};

Object.freeze(obj);

obj.price = 10;
obj.id = '1';
console.log(obj);
```

### 🔥`Object.fromEntries()`

`Object.fromEntries()`方法将可迭代的键值对集合转换成对象。

可迭代的键值对集合可以是数组、Map 或其他实现了 `iterable` 接口的对象。

```js run
const arr = [
	['id', 1],
	['name', 'car'],
	['category', 'unknown'],
];

console.log(Object.fromEntries(arr));
```

### 🔥`Object.getOwnPropertyDescriptor()`

`Object.getOwnPropertyDescriptor()`方法获取某个属性的特性。

```js run
const obj = {
	id: 1,
};

console.log(Object.getOwnPropertyDescriptor(obj, 'id'));
```

### `Object.getOwnPropertyDescriptors()`

`Object.getOwnpropertyDescriptors()`方法获取对象上所有属性的特性。

```js run
const obj = {
	id: 1,
	type: 2,
};

console.log(Object.getOwnPropertyDescriptors(obj));
```

### `Object.getOwnPropertyNames()`

TODO

### 🔥`Object.getOwnPropertySymbols()`

`Object.getOwnPropertySymbols()`返回对象中的所有 `Symbol` 属性。

```js run
const s1 = Symbol();

const o = {
	id: 0,
};

o[s1] = '1';

// 没有返回o.id
console.log(Object.getOwnPropertySymbols(o));
```

### `Object.getPrototypeOf()`

`Object.getPrototypeOf()`方法用于获取对象的原型。

```js run
const prototype = {};

const o1 = Object.create(prototype);

console.log(Object.getPrototypeOf(o1) === prototype);
console.log(Object.getPrototypeOf(o1) === o1.__proto__);
```

### 🔥`Object.is()`

`Object.is()`用于比较两个值是否相等。

```js run
const o1 = {
	p1: true,
	p2: null,
	p3: 1,
	p4: 'str',
};

const o2 = {
	p1: true,
	p2: null,
	p3: 1,
	p4: 'str',
};

console.log(Object.is(o1, o2));
console.log(Object.is(o1.p1, o2.p1));
```

`Object.is()`和`==`不同，`==`会先尝试将两个值转换为相同类型，比如`"" == false`结果为 `true`。`Object.is()`不会进行类型转换。

`Object.is()`和`===`也不同。`===`会将`-0` 和`+0` 相等，`NaN` 不等于 `NaN`。

```js run
console.log(Object.is(NaN, NaN)); //true
console.log(NaN === NaN); // false

console.log(Object.is(-0, +0)); // false
console.log(-0 === +0); //true
```

### `Object.isExtensible()`

TODO

### `Object.isFrozen()`

### `Object.isSealed()`

### `Object.keys()`

### `Object.preventExtensions()`

TODO

### `Object.seal()`

### `Object.setPrototypeOf()`

### `Object.values()`

## 实例方法

### `Object.prototype.__defineGetter__()`

TODO

### `Object.prototype.__defineSetter__()`

TODO

### `Object.prototype.__lookupGetter__()`

TODO

### `Object.prototype.__lookupSetter__()`

TODO

### `Object.prototype.hasOwnProperty()`

### `Object.prototype.isPrototypeOf()`

### `Object.prototype.propertyIsEnumerable()`

### `Object.prototype.toLocaleString()`

### `Object.prototype.toString()`

### `Object.prototype.unwatch()`

### `Object.prototype.valueOf()`

### `Object.prototype.watch()`

> -   [Object —— MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
