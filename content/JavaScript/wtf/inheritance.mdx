---
title: '几种继承方式'
slug: 'inheritance'
date: '2020-11-27'
category: 'JavaScript'
index: 11
authors:
    - cuvii
authorsUrl:
    - https://fei.kodin.fun
draft: false
---

## 原型链继承

```js run
function People(name, age) {
	this.name = name;
	this.age = age;
}

People.prototype.whoami = function () {
	console.log(`我是${this.name}, 今年${this.age}`);
};

function Student(name, age) {
	this.name = name;
	this.age = age;
}

Student.prototype = new People();

const s1 = new Student('lilith', '20');

s1.whoami(); // 我是lilith，今年20
```

上面是原型链继承的例子，Student 函数继承 People。

这种继承是通过手动设置 `Student.prototype` 为 `People` 的实例来实现的。

原型链继承一个很大的问题在于，由于是手动将`Student.prototype`设置为`People`的实例，没办法向 People 传参。

在上面代码中，Student 函数中的 name 和 age 属性显得非常多余，试想一下如果是多层继承，或者多个参数，体验会非常差。

另一个问题是，People 中的引用类型属性会被共享。

```js run
function People() {
	this.friends = [];
}

function Student() {}

Student.prototype = new People();

const s1 = new Student();
s1.friends.push('will');

const s2 = new Student();
s2.friends.push('Carl');

console.log(s1.friends); // [ 'will', 'Carl' ]
console.log(s2.friends); // [ 'will', 'Carl' ]
```

哦豁，s1 和 s2 的 friends 是共享的。由于原型链的关系，`s1.__proto__.friends`和`s2.__proto__.friends`操作的是同一个数组。

> ### 总结
>
> 原型链继承有两个问题：
>
> -   子类无法向父类传参。
> -   父类中的引用类型会被所有实例共享。

## 盗用构造函数

> 核心思路：在子类中调用父类的构造函数

```js run
function People(name, age) {
	this.name = name;
	this.age = age;
}

People.prototype.whoami = function () {
	console.log(`我是${this.name}, 今年${this.age}`);
};

function Student(name, age) {
	People.call(this, name, age);
}

Student.prototype.sayHi = function () {
	console.log(`你好，我是${this.name}`);
};

const s1 = new Student('lilith', '20');
// s1.whoami() // s1.whoami is not a function
s1.sayHi(); // 你好，我是lilith
```

`Student` 的实例 `s1` 没有访问到` whoami` 这个属性。因为根据原型链，`s1.__proto__`为`Student.prototype`，`Student.prototype`上没有`whoami`属性，而且`Student.prototype.__proto__`为`Object.prototype`。

通过这种方式解决了子类向父类传参的问题，但是又无法访问父类中的函数。

> ### 优点
>
> -   解决子类向父类传参的问题。
> -   避免父类中的引用类型会被所有实例共享。
>
> ### 缺点
>
> -   子类无法访问父类原型上的方法。
> -   父类中的方法会被创建多遍。

关于<mark>父类中的方法会被创建多遍</mark>。

由于子类无法访问父类原型，一种解决思路如下：

```diff
function People(name, age){
    this.name = name;
    this.age = age;
+   this.whoami = function () {
+       console.log(`我是${this.name}, 今年${this.age}`);
+   };
}

- People.prototype.whoami = function () {
-	console.log(`我是${this.name}, 今年${this.age}`);
- };



function Student(name, age){
    People.call(this,name, age)
}

Student.prototype.sayHi = function(){
    console.log(`你好，我是${this.name}`)
}

const s1 = new Student('lilith', '20');
s1.whoami() // 我是lilith，今年20

```

将 `whoami` 方法从 `People` 原型上移动到 `People` 实例中。这样子类也有 `whoami` 方法，但是每一次创建 `Student` 实例，就会创建一个不同的 `whoami` 方法，产生额外内存开销。

## 组合继承

组合继承=原型链继承+盗用构造函数

原型链继承可以实现访问父类原型的方法，而盗用继承可以解决子类向父类传参的问题。组合继承就是将这两点结合起来。

```js run
function People(name, age) {
	this.name = name;
	this.age = age;
}

People.prototype.whoami = function () {
	console.log(`我是${this.name}, 今年${this.age}`);
};

function Student(name, age) {
	// 继承属性
	People.call(this, name, age);
}

// 继承方法
Student.prototype = new People();

Student.prototype.sayHi = function () {
	console.log(`你好，我是${this.name}`);
};

const s1 = new Student('lilith', '20');
s1.whoami(); // 我是lilith, 今年20
s1.sayHi(); // 你好，我是lilith
```

## 原型式继承

```js run
function createObj(o) {
	function F() {}
	F.prototype = o;
	return new F();
}
```

原型式继承实际上就是`Object.create()`方法的实现，传入一个参数，返回一个以参数为原型的空对象。

```js run
// https://github.com/mqyqingfeng/Blog/issues/16#4.%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF
function createObj(o) {
	function F() {}
	F.prototype = o;
	return new F();
}

var person = {
	name: 'kevin',
	friends: ['daisy', 'kelly'],
};

var person1 = createObj(person);
console.dir(person1); // {}
var person2 = createObj(person);
console.dir(person2); // {}

person1.name = 'person1';
console.log(person2.name); // kevin

person1.friends.push('taylor');
console.log(person2.friends); // ["daisy", "kelly", "taylor"]
```

这里需要注意，person1 和 person2 都是空对象。

`person1.name = 'person1'`时，是为 person1 添加 name 属性。

而`person2.name`时，由于 person2 是空对象，所以会去原型对象上找。

> `[[Get]]`操作才会触发原型链查找，`[[Set]]`操作不会触发原型链，是直接在实例上进行的。

另外可以看到，依然存在原型链继承中，父类中的引用类型属性会被所有子类共享。

## 寄生式继承

寄生式继承类似于工厂模式：创建一个实现继承的函数，增强新对象，然后返回该对象。

```js
function createObj(o) {
	const clone = Object.create(o);
	o.sayHi = function () {
		console.log('hi');
	};
	return clone;
}
```

寄生式继承最大问题还是每次创建对象都会创建一遍方法。

## 寄生组合式继承

在组合式继承中，通过对构造函数的两次调用，分别实现属性和函数的继承。

```js
function Student(name, age) {
	// 继承属性
	People.call(this, name, age);
}

// 继承方法
Student.prototype = new People();
```

在继承方法时，调用 `new People()`时会创建一个 `People` 的实例，将该实例作为 `Student.prototype` 的原型。此时 `Student.prototype` 中除了 `whoami` 方法之外，还会有 `name`和`age`属性。

需要对这一步进行优化。

思路是，让 `Student.prototype = People.prototype`。

TODO

> -   [JavaScript 深入之继承的多种方式和优缺点](https://github.com/mqyqingfeng/Blog/issues/16)
> -   [JavaScript 高级程序设计 第四版 8.3 继承](https://www.ituring.com.cn/book/2472)
> -   [Javascript – How Prototypal Inheritance really works](http://blog.vjeux.com/2011/javascript/how-prototypal-inheritance-really-works.html)
